（耦合性，抽象性，隐藏性，重用性，拓展性）
原则：做任何事情最基本的原则
	开闭原则：对拓展开放，对修改关闭（可以拓展原模块，不应该修改已写好的）
	实现：（即如何实现代码是可拓展的，不需要修改原代码的）
	“抽象”，区分变与不变，不变的抽象为接口，变化的都单独封装
	--拓展，重用

	单一职责原则：就一个类而言，应该仅有一个引起他变化的原因
	（一个类无需负责多余的功能，类似功能的代码应该集合在一个类里，高内聚低耦合）
	（当一个工具方法很多类里面都有实现，后来的开发人员就得重新去维护和辨别到底该用那个才是对的，或者干脆
	只能自己重新实现）
	--重用
	
	里氏替换原则：子类必须是可以替换基类的
	继承
	--重用，拓展
	
	依赖倒置原则：1，依赖抽象（高层不应依赖底层模块，抽象不应依赖细节）2，面向接口编程，而不是面向实现（自顶向下）
	依赖抽象和面向接口，即可实现依赖倒置（更换不同的）
	
	--拓展
	
	接口隔离原则：抽象接口时尽量避免创建多余的方法。多余的方法应该接口继承接口的方式存在于更适当的接口。
	（实现时不会有空方法了，调用时不会有莫名其妙的方法了）
	
	
创建型：
	--解耦
		
	 工厂方法模式：
	 工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类时那个。工厂方法让类把实现推迟到子类。
	 “抽象工厂，具体工厂，抽象产品，具体产品”
	 
	 通过工厂方法生产对象
	 
	 抽象工厂模式：
	 工厂方法接口，创建相关或依赖对象的家族，而不需要明确指定具体类。
	 
	 与工厂方法类似。不同的是：
	 工厂方法：只生成某一个具体对象
	 抽象工厂：生成一组对应的对象（如：具体工厂1生产对应的产品A1，产品B1，A1和B1应该是要组合在一起用）
	 
	 单例模式：
	 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
	 
	 整个系统都只有某个类的一个实例。
	 1构造方法私有。
	 2饿汉式注意使用final，懒汉式注意使用synchronized（否则可能就是多例）
	 
	建造者模式：
	见builder的时序图
	
	builder（抽象建造者），concretebuilder（具体建造者），director（导演者），product（产品）
	
	原型模式：
	通过已有的对象复制出新的对象
	
	
构造型：

	桥接模式：
	
	极大的将各具体实现拆分为不同的模块，拆分更加细致具体
	
行为模式：做一类事情的基本模式

	备忘录模式
	
	策略模式
		看下面模版
	
	迭代器模式
	
	
	访问者模式
	
	
	观察者模式
		观察者模式
	 * 做一件事，监听者观察到事件的发生
	 * 
	 * 通过注册监听器，组合模式即可实现
	
	解释器模式
	
	
	命令模式
	
	
	模板方法模式
		模版---变与不变
	 * 做一件事，有固定的部分与需要输入的部分。
	 * 定一个模版来接收变动的参数，做这件事的方法就写好了。
	 * 
	 * *当这个模版方法定在当前类里面，具体类只要实现模版方法即可
	 * 
	 * *当把这个所谓的模版定在接口里面，接口作为参数。此时变动通过接口写好了。
	 * 实际运行时，变动的部分动态绑定到实际的实现
	 * 
	 * 都可以将同时有变和不变的方法写好。
	
	责任链模式
		责任链--给A做一件事，A把职责以外的事交给B，B把职责以外的事交给C
	 * (链条的顺序时固定，他们的职责时互斥的)
	 * 
	 * 通过组合即可实现
	  场景：对于一个请求多个对象都可以处理，1，普通的做法是，在客户端创建这些对象，然后按顺序来处理并判断直到其中一个
	 处理成功。（1，这样所有对象都耦合到客户端里面。2，虽然也可以重用，但是耦合死的代码不具备拓展性）
	 2，采用责任链模式，便可以隐藏实现，协调多个对象一起工作，同时方便拓展。
	
	中介者模式
		中介模式---不直接联系，通过中介联系
	 * 
	 * 实现
	 * 两个对象同时持有中介，没有直接关系
	 * 中介同时持有两个对象，传递消息
	 * 通过组合即可实现
	
	 
	状态模式
		状态模式--对象在不同的状态有不同的行为
	 * 
	 * 对象的状态：对象属性值不同，就是不同的状态
	 * 
	 * 组合模式即可实现